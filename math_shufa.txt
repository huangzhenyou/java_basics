#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <dos.h>
#define MAXSIZE 50000
typedef int KeyType;
typedef int InfoType;
typedef struct{
  KeyType key;
  InfoType otherinfo;
}RedType;
typedef struct{
  RedType r[MAXSIZE+1];
  int length;
}SqList;

/*直接插入排序*/
void InsertSort(SqList *L)
{
  int i,j;
  for(i=2;i<L->length+1;++i)
    if (L->r[i].key<L->r[i-1].key)
	{
      L->r[0]=L->r[i];
      for(j=i-1;L->r[0].key<L->r[j].key; --j)
         L->r[j+1]=L->r[j];
      L->r[j+1]=L->r[0];
    }
 }


/*折半插入排序*/
void BInsertSort(SqList *L)
{
  int i,j;
  int low,high,m;
  for(i=2;i<L->length+1;++i){
    L->r[0]=L->r[i];
    low=1;high=i-1;
    while(low<=high){
      m=(low+high)/2;
      if (L->r[0].key<L->r[m].key)
         high=m-1;
      else low=m+1;
    }
    for(j=i-1;j>=high+1;--j)
      L->r[j+1]=L->r[j];
    L->r[high+1]=L->r[0];
  }
}

/* 快速排序 */
int Partition(SqList *L,int low,int high)
{
  int pivotkey;
  L->r[0]=L->r[low];
  pivotkey=L->r[low].key;
  while(low<high){
    while(low<high&&L->r[high].key>=pivotkey) --high;
    L->r[low]=L->r[high];
    while(low<high&&L->r[low].key<=pivotkey) ++low;
    L->r[high]=L->r[low];
  }
  L->r[low]=L->r[0];
  return low;
}
void QSort(SqList *L,int low,int high)
{
  int pivotloc;
  if(low<high){
    pivotloc=Partition(L,low,high);
    QSort(L,low,pivotloc-1);
    QSort(L,pivotloc+1,high);
  }
}
void QuickSort(SqList *L)
{
  QSort(L,1,L->length);
} 

/*直接选择排序*/
int SelectMinKey(SqList L,int i)
{
  int k;
  int j;
  k=i;
  for(j=i;j<L.length+1;j++)
    if(L.r[k].key>L.r[j].key)
      k=j;
  return k;
}
void SelectSort(SqList *L)
{
  RedType t;
  int i,j;
  for(i=1;i<L->length;++i)
  {
    j=SelectMinKey(*L,i);
    if(i!=j)
	{
      t=L->r[i];
      L->r[i]=L->r[j];
      L->r[j]=t;
    }
  }
} 

/*堆排序*/
typedef SqList HeapType;
void HeapAdjust(HeapType *H,int s,int m)
{
  RedType rc;
  int j;
  rc=H->r[s];
  for(j=2*s;j<=m;j*=2){
    if((j<m)&&(H->r[j].key<H->r[j+1].key)) ++j;
    if (rc.key>=H->r[j].key) break;
    H->r[s]=H->r[j];
    s=j;
  }
  H->r[s]=rc;
}
void HeapSort(HeapType *H)
{
  RedType t;
  int i;
  for(i=H->length/2;i>0;--i)
    HeapAdjust(H,i,H->length);
  for(i=H->length;i>1;--i){
    t=H->r[1];
    H->r[1]=H->r[i];
    H->r[i]=t;
    HeapAdjust(H,1,i-1);
  }
}


void main()
{
  int i,k;
  SqList s;
  clock_t start,end;

  for(i=1;i<50000;i++)
    {
      s.r[i].key=rand();
      printf("%d ",s.r[i].key);
    }
  s.length=i-1;
  printf("\nThe record to be sort:\n");
  printf("\n\t1、直接插入排序\n\t2、折半插入排序\n\t3、快速排序\n\t4、直接选择排序\n");
  printf("\t5、堆排序\n\n\t按1..5选择不同的排序方法:");
  scanf("%d",&k);
  switch(k){
    case 1:
      start=clock();
      InsertSort(&s);
      break;
    case 2:
		start=clock();
      BInsertSort(&s);
      break;
    case 3:
		start=clock();
      QuickSort(&s);
      break;
    case 4:
	  start=clock();
      SelectSort(&s);
      break;
    case 5:
		start=clock();
      HeapSort(&s);
      break;
    default:printf("No function which you select.\n");
  }
  printf("\nThe records be sorted:\n");
  for(i=1;i<50000;i++)
    printf("%d  ",s.r[i].key);
  end = clock();
 
  printf("%f",(double)(end-start)/CLK_TCK);
  printf("\n\n\tPress any key to exit.\n");
  getchar();
}
